## 专题：哈希
### 1.两数之和
- 第一次遍历构建val-idx的哈希表
- 第二次遍历找互补元素是否在哈希表中
- 优化：将构建哈希表和查找哈希表合并；先查找哈希表，如果存在互补元素就可以返回；如果不存在互补元素，就把自己插进去；

### 49.字母异位词分组
- 将string排序，作为哈希表的key
- 哈希表的value存储结果数组

### 128.最长连续序列
- 判断序列长度：固定某个数作为起点，看往后的多少个元素都在数组中
- 快速判断存在：使用哈希表快速判断某个数是否在数组中
- 优化1：只有序列的头元素才进入判断，如果存在前继元素则直接跳过不判断
- 优化2：遍历时，不要遍历原数组，遍历哈希集合，避免重复元素，效率更高

## 专题：双指针

### 283.移动零
- 难点：要原地移动，非零元素顺序不变
- 思维转换：移动零 -> 移动非零
- 顺序移动非零元素到一边，一定会保证其相对顺序不变
- 一个指针i用于遍历和探测非0元素(for循环)；一个指针sub用于维护已经检查/置换过的非零子数组，用于置换


### 11.装水最多的容器
- 肯定是要遍历才能找到最大值，但该如何高效遍历呢？
- 使用双指针，表示容器的左右
- 【关键】容量被两边的最小元素限制，只有改变更小的那个指针，才有可能寻找到更大值
- 采用上述策略，不断移动更小的那个指针，记录整个过程的最大值即可

### 15.三数之和
- 难点在于避免重复

**首先考虑朴素的三层循环**
- 重复包括：（1）下标的重复遍历；（2）元素的重复
- 【下标约束】采用循环时，保证三层循环满足 i < j < k
- 【元素去重】需要对数组排序，让i, j, k分别掌管三元组三个位置的元素；每层循环都要跳到下一个非重复元素

**然后考虑降维机会**
- 将三维的循环，降到二维，固定`nums[i]`时， 在有序数组下 j 和 k 的遍历可以简化为 O(N) （双指针一次遍历）
- j, k 要满足下标约束，j 从 i+1 开始，k 从另一端 n-1 开始
- 【双指针】如果三者和>0，k左移；如果三者和<0，j右移；
- 如果match了（=0），j, k跳过重复元素抵达下个位置，继续寻找可能的值（j++值会递增，k--值会递减）

### 42. 接雨水

**左/右边界数组**
- 从一个位置的视角出发
- 关键：一个位置的接水量，取决于其左右侧最大高度的最小值
- 难点：如何获取每个位置的左右侧最大高度
- （最简单的方式是$O(N^2)$ ，固定每个元素，向左向右遍历数组）
- 分别使用一次从左到右/从右到左遍历，维护遍历到的最大值`max_val`，不断更新最大值视图（与121.买卖股票的最佳时机 维护最小值视图 一致），记录为`left`和`right`数组。
- 最后一次遍历数组，计算出接水量，共3次O(N)遍历

**左/右边界双指针**
- 很自然的想法是能不能将3次遍历，合成1次，且不需要额外的数组
- 使用左、右指针从两边同时开始遍历，维护左/右最大值视图 left_max 和 right_max。
- left_max < right_max，说明左指针指向的元素，其容器边界已经确定
- 该元素，左边界已经确定是left_max，虽然右边界还没确定，但确定的右边界只会大于现在的right_max，不可能成为容器边界
- 反之 right_max > left_max 同理
- 因此，哪边小处理那边的元素就行了

**单调栈**
- 从凹形形状出发，用单调栈存递减柱子，当比栈顶更高的柱子（类似 739.每日温度），说明形成凹，可以装水
- 如何计算：**横着** 计算雨水面积（利用间距），注意 **减掉坑底**
- 元素弹出：（1）栈顶元素是坑底元素（没法装水），弹出作为坑底（无需额外维护坑底）；（2）弹出坑底后，露出的是左右挡板，计算装水；（3）一直弹，把比新元素的小的全弹走，然后将新元素入栈为栈顶；
- 优化：相同元素形成长坑底，把和新元素相等的也弹走，栈中只维护长坑底中的一个元素

## 专题：滑动窗口


## 专题：子串

### 560. 和为K的子数组
- 此问题最核心的特点在于：（1）必须要求**连续**，不能自由判断每个元素取还是不取（区别于和为K的子序列，0-1背包问题的变体）；（2）是**计数**问题，不太具有最优子结构。是没法使用迭代表达式做动态规划，或者递归记忆化搜索的。

**从结尾元素回溯（超时）**
- 以结尾元素做标记，区分不同子数组
- 从结尾元素回溯，一遍遍历到开始元素，看有多少区间满足条件（注意，一个结尾元素可能有多个满足条件的区间）
- 遍历整个数组元素做结尾元素，然后把所有可能结果相加即可
- 时间复杂度是O($N^2$)

**前缀和+哈希表**
- 对数组计算前缀和数组 s
- 注意要覆盖全部子数组，因此前缀和数组 s 第一个元素为0，大小为n+1
- `s[j]` - `s[i]` 可以表示 子数组`nums[i, .., j-1]`的和
- 然后问题可以转化为类似于 1.两数之和的思路
- 使用哈希表将两层循环变为一/两次循环
- 本题难点：如何在哈希表维护 `j > i` 的条件
- 即遍历到的 j，只能找其之前的 i，其之后的 i 不能找（局部视图）
- 方法：某个前缀和`sj`的`si = sj - k`的查找（多少个） 和 `sj`的哈希表插入 同步进行，在一次遍历中操作。这样 `sj` 只能看到其前缀的哈希表信息，达到局部视图

## 专题：普通数组

### 53.最大子数组和
- 可变性：虽然子数组连续；但最优子数组仍可能改变（解决思路同 300.最长递增子序列）
- 突破口：和一定源于和之前元素相加，进而判断最大。
- 问题改造：以当前元素【结尾】的子数组最大和 f(n)
- 递归关系：当前元素`nums[i]`和之前的最大和 f(n-1) 相加，与`nums[i]`自身相对比；确定新的当前元素结尾最大子数组最大和 f(n)。
- 最终答案：h(n) = max{f(i)} (i<n)，得到最终答案

### 56.合并区间
- 对所有区间的左边界排序，然后用右边界探测，新区间能否被收纳
- 待合并区间的左边界无需被更新，只用更新右区间
- 每次答案数组的最后一个区间为待合并区间，也只会开放一个区间，有点类似于zone
- 实现对特定结构的`vector`排序
```cpp
auto cmp = [](vector<int>& a, vector<int>& b) {
	return a[0] < b[0]; // 注意 return 表示排序 a 在 b 前，此处定义越小越前，升序
};

sort(target.begin(), target.end(), cmp); 
```
- 注意 `vector<vector<int>> ` 的默认排序方式，对子`vector`的第一个元素排序，相同则第二个元素，以此类推，因此本题默认`sort`即可。

### 238. 除自身以外数组的乘积

**前/后缀积**
- 使用两个前/后缀乘积数组，`prev[i]`代表在 i 之前的元素乘积，`post[i]` 代表在 i 之后的元素乘积
- 优化：直接在返回数组上操作，正向遍历填 `prev` 数组（同上），反向遍历乘上 `post` 变量（实时维护）




## 专题：矩阵

### 73.矩阵置零

**哈希集合**
- 遍历整个矩阵，出现零就把其 i, j 分别塞入两个哈希集合
- 遍历两个哈希集合，将对应行列置零
- 空间复杂度O(m+n)

**行/列首元素标记**
- 用第一行/第一列的首个元素`matrix[0][j]`/`matrix[i][0]`记录该列/行是否有零
- 但要先记录好第一行/列的含零信息（因为会被覆盖和破坏）
- 遍历非第一行/列的所有元素，有零就标记在`matrix[0][j]`/`matrix[i][0]`
- 再次遍历非第一行/列的所有元素，对应`matrix[0][j]`/`matrix[i][0]`为0，就将元素置零（注意第一行/列跳过不处理，留给标记变量处理）
- 根据标记变量，处理第一行/列是否需要全部置零

## 专题：链表

### 160.相交链表

**暴力遍历**
- 用两个`Node*`指针和for循环遍历两个链表，遇到相同节点就break

**哈希集合**
- 先遍历链表A，将每个节点塞入哈希集合
- 再遍历链表B，判断节点是否在哈希集合

**双指针/相同路程法**
 - 指针a走完链表A，再去走链表B
 - 指针b走完链表B，再去走链表A
 - 两者一定会在首个相交点相遇（即指向相同节点）

### 206.反转链表

**迭代：摘取头插法**
- 遍历链表，依次完成 **cur的next指针** 的转向
- 原地反转链表 一定要三个指针，记录前驱prev，当前cur，以及后继next
- （只用两个指针，指针会发生指针覆盖）
- **注意1**：需要 **先保留** 其原来后继，**再修改** cur->next，否则无法往后继续定位；**先保留** 好前驱，**再修改** cur，否则逻辑出错。
- **注意2**：修改第一个前驱prev的next指针，防止生成环
- **注意3**：此刻还不确定cur是否是nullptr， 后继next可以先置空

```cpp
// 整个反转
Node* reverse(Node* head){
	if (head == nullptr) return head;
	
	Node* prev = head;
	Node* cur = head->next; // head已经确定不空了
	Node* next = nullptr; // cur不确定空不空 先不要cur->next
	
	prev->next = nullptr; // 避免环
	
	while (cur != nullptr) { // 修改每一个cur的指向
		next = cur->next; // cur已经确定不空了，先保存原来后继
		cur->next = prev;
		
		prev = cur;
		cur = next;
	}
	
	return prev; // prev是最后一个节点，cur现在已经是nullptr
}

// 区间反转
Node* reverse(Node* head, Node* tail) {
	... // 同上
	while (cur != nullptr && prev != tail) { // 加上tail的判别
		...// 同上	
	}
	...// 同上	
}
```

**递归：拼接法**
- 难点1：如何构造递归？构造递归后如何完成拼接？
- （1）构造：当前节点head | 链表rest；（2）拼接：让链表rest的最后一个节点new_last指向当前节点head
- 难点2：如何得到rest链表的首/尾节点（new_head/new_last）？
- （1）首节点new_head：通过递归返回值返回；（2）尾节点new_last：当前节点仍指向呢（head->next）
- 难点3：用完head->next后该如何处理？
- （1）其仍然指向上述的new_last，构成了环，将其置空；（2）留到下层递归会更新其指向。
- 难点4：递归开始条件？
- 空节点，或单个节点，直接返回其自身


### 234.回文链表

**数组转储**
-  难点：链表只能顺序遍历；回文匹配需要正序和逆序同时进行判断相等
- 借助O(N)遍历，将链表转储为数组，可双向遍历
- 然后遍历一遍数组，用首尾指针做比较

**递归逆序**
- 如果继续在链表上判断，需要考虑逆序遍历链表
- 如何逆序遍历链表，递归提供了一种类似于栈的、优雅的逆序遍历（或者直接用stack迭代，两者等价）
- 然后通过一个递归外的全局指针，可以控制顺序遍历
- dfs **结束** 一次就匹配并移动一次递归外全局指针

**反转链表**
- 反转后半段链表实现逆序访问，访问完后再反转回来
- 定位后半段链表的头、尾可以用快慢指针
- 快慢指针的快指针，需要加 fast->next 的判断来看fast指针到末尾没。
- 需要考虑各种边界情况
- 实现区间<head, ..., tail>的链表反转，需要在206.反转链表基础上，要额外加一个tail的判断

```cpp
// 快慢指针找链表中间节点(无需管fast指针)

//  寻找后半段的起点 判断探测1步
Node* sf_visit(Node* head) {
	Node *fast = head, *slow = head;
	while (fast != nullptr && fast->next != nullptr) { 
		slow = slow->next;
		fast = fast->next->next;
	}
	return slow;
}

// 寻找前半段终点 判断探测2步（让slow前进更保守）
Node* sf_visit(Node* head) {
	if (head == nullptr) return head;
	Node *fast = head, *slow  = head;
	while (fast->next != nullptr && fast->next->next != nullptr) {
		slow = slow->next;
		fast = fast->next->next;
	}
	return slow;
}
```

### 141.环形链表

**哈希集合**
- 遍历链表，同时将节点存入哈希集合，后续遍历遇到重复则说明有环

**快慢指针**
- 存在环，遍历一定会陷入无限循环
- 用快慢指针，一起遍历链表，如果快慢指针相遇，则说明在环内循环套圈了

### 142.环形链表Ⅱ

和141.环形链表进阶的地方在于求第一个环节点

**哈希集合**
- 同141.环形链表，遇到第一个重复的node就是第一个环节点

**双指针**
- Step 1. 同 141.环形链表 判断是否成环
- Step 2. 若成环，快慢双指针相遇后，让其中一个指针再走一圈，计算出环长C
- Step 3. 用距离为C的同速双指针（让一个指针先走C步），遍历至相遇，相遇点就是环起点


### 21.合并两个有序链表

**递归归并**
- 递归返回值：设计为结果链表的头节点
- 递归子问题：按照val1和val2的大小，决定递归的子问题
- 递归操作：将当前选择的节点cur，和递归的子链表sub做拼接
- 递归结束条件：（1）都为空，反回空；（2）一个为空，直接返回另一个数组（已有序）

**迭代归并**
- 都不空选小的，空了直接选另一个。为了简洁考虑，归并一般都采取：step1. 处理都不空的部分；step2. 一个空了直接选择另一个
- 维护主链表逻辑，采用尾插法
- 在新链表的头节点不确定，可以采用虚拟的哨兵节点dummy，确定了头节点后，再填给dummy->next即可
```cpp
Node* merge(Node* l1, Node* l2) {
	Node dummy(0);
	Node* tail = &dummy;
	
	while (l1 != nullptr && l2 != nullptr) {
		if (l1->val <= l2->val) {
			tail->next = l1;
			l1 = l1->next;
		}
		else {
			tail->next = l2;
			l2 = l2->next;
		}
		tail = tail->next;
	}
	
	tail->next = l1 == nullptr ? l2 : l1;
	return dummy.next;
}
```

### 2.两数相加
- 顺序遍历两个链表l1和l2，相加每一个节点
- 加法原理模拟：用%10获取本位，用/10获取进位，每次除了两树相加还要加进位
- 短的链表加完了(nullptr)，就视为0
- 维护结果链表head，预分配下个节点为val(-1)以简化操作，最后预分配节点是否仍是-1判断该节点是否被使用

### 19.删除链表的倒数第N个节点

**两次遍历**
- 第一次遍历计算链表长度L，定位倒数第N个节点的位置 L - N 
- 第二次遍历找到 L-N 即答案

**递归遍历**
- 维护递归外的全局变量，记录是倒数第几个元素
- 如果是删除头节点，直接返回node->next
- 如果是删除非头节点，留到其父节点处理

**栈遍历**
- 第一次遍历push节点入栈，然后pop n个栈顶元素出来

**距离为N的同速双指针**
- fast 和 slow指针同速，距离为N
- 当fast指针遍历结束时，slow指针就指向倒数第N+1个节点

### 24.两两交换链表的节点

**迭代遍历**
- 用两个指针 p1 和 p2，一起往前移动
- 修改两节点：交换p1和p2，修改两者next指向
- **修改前序节点**：p1和p2交换，会导致前序节点的next指向错误，（本来指向p1，现在交换要指向p2）
- 需要额外的指针p3，记录上一轮的前序节点


**递归遍历**
- 递归具有天然的逆序遍历特点，无需考虑正向遍历还要记录前驱节点被修改情况
- 递归返回值：处理好（两两swap处理）的子链表的头节点
- 递归结束条件：空节点/单个节点，无需swap，返回head即可
- 递归操作：否则获取目标节点p1，p2，子节点sub，修改p1和p2指向；返回p2；

### 25.K个一组翻转链表

**基于递归**
- **递归构造：** 将链表划分为 要翻转的K个 + 剩余子链表；然后每次递归处理K次翻转
- **递归开始：** 如果翻转的节点数不够K个了，直接返回不翻转
- **递归返回值：** 返回处理过后链表的头节点
- 但是递归无法实现 常数级空间开销

**基于迭代**
- 将上述剩余子链表的逻辑用迭代继续实现
- 【指针记录】K个一组的迭代，需要记录多个指针：| （上一组） ...prev | cur ...（当前 K 个 1组 ）... cur_tail | next ... （剩下的） |
- 【指针修改】每次除了将 当前 K 个1组反向为 cur_tail ... cur 外，还要将“上一组”和“当前组”指针关系，"当前组"和”剩下的“指针关系

**两个方法都需要处理一个问题就是**
- 如何优雅实现，判断剩下的链表长度是否还有K个长度，如果有K，需要准确停在第K个节点
- 用for统一直接前进 K - 1 步：（1）到nullptr，长度不够了；（2）节点不空，落点就是第K个节点

```cpp
Node* cur = head; // 注意第一个node已经算长度1了 故下面前进 K - 1 步
for (int i = 0; i < K - 1; i++) 
	if (cur != nullptr) cur = cur->next;
if (cur == nullptr) // 说明走 K - 1 步，到nullptr，长度不够了
... // 如果节点不空，前进K-1步，就落在第K个节点
```


### 138.随机链表的复制

**迭代+哈希表**
- 第一次遍历构建新链表节点，并把旧-新节点映射关系存入哈希表
- 第二次遍历，更新新链表节点的next和random指针

**递归回溯+哈希表**
- 【递归逻辑】应该表示为 旧节点的“新链表节点” 的构建
- 【递归构造】如果某个旧节点不在hash_map，则一定没构建”新链表节点“，于是**创建构建**，将其存入哈希表，并递归构建”新链表节点“的next/random节点
- 【递归结束】如果某个节点已经在hash_map，则直接返回（无需考虑其next/random节点是否构建），因为在**创建构建**时一定会更新next/random指针。即，空白节点的返回机制，哈希表存入一定要在递归构建next/random节点前。
- 例如：当random/next指向自己时，即使当前节点没构建完，又递归向自己，也能直接返回第一次对该节点 **创建构建** 的地址，即便此次返回时，节点的next/random还没构建起来。
- 【递归返回值】设计为创建的”新链表节点“新地址

**链表耦合与拆分**
- next的指针相对顺序，**主要难点** 是random指针随机性
- random的随机性，要求维护旧-新节点的映射关系，不然每次重新遍历很低效
- 但想不用额外空间，那只能将新节点和旧节点"耦合"起来，形成隐式的映射
- 具体操作是，将旧节点A的next指针指向新节点A'，并将新节点A'的next指针指向原来的下一个节点B。形如：A -> A' -> B -> B' ...
- Step 1. 申请新节点，并修改所有节点的next指针，实现链表整合
- Step 2. 遍历链表，修改所有新节点的random指针
- Step 3. 遍历链表，重新修改next指针，实现链表拆分

### 148.排序链表

数组的归并排序参考 ”归并排序“ 一节

注意链表和数组本质区别：
- 数组的顺序由**物理位置**决定（要排序就得搬数据），归并一定要**拷贝**子数组副本
- 链表的顺序由**指针连接**决定（要排序只需改指针），归并可以直接**原地**修改指针

子链表的合并 参考 21.合并两个有序链表

**递归版归并排序**
- 【递归操作】采用链表的归并排序，找到链表中点，分为左右两个子链表，递归对两个子链表归并排序
- 【递归停止】空链表/单个链表节点直接返回
- 【递归返回】链表归并的递归直接返回 **归并结果`Node*`**；递归只是为了用一个栈存储 归并展开的所有 **中间归并结果`Node*`**
- 【注意1】链表的归并可以原地修改指针
- 【注意2】链表递归尽量别涉及区间，即head和tail，不然会变得很复杂/不幸；正确做法是做拆分，子链表必须改造为以nullptr结尾，然后直接对一个头节点递归就可以了
- 寻找链表中点 参考 234.回文链表，【注意3】此处链表拆分要在寻找中点时一起完成。【注意4】如果不够拆怎么办？这一层不考虑这个事，交给递归函数的停止条件处理。

**迭代版归并排序**
- 核心思路参考：数组版的归并排序（迭代版）
- 不断增大有序数组的sz，每个sz下，都采用两两合并的方式
- 【链表原地归并】但在链表下，做原地合并，又和数组索引的归并不太一样；在每个sz下要想实现链表两两合并，需要三步：
- Step 1【链表摘取】. 从现有的链表摘下，两个，长度为sz的子链表
- 封装一个摘取函数：摘取长度为k的链表，并返回剩余链表头节点。采用前进k-1步的方式。注意，长度不够情况的处理。
- Step 2【链表合并】. 将上述两个有序子链表合并，并返回合并链表的头尾：sub_head，和sub_tail
- 封装一个合并函数：将两个有序子链表合并，并返回头/尾指针
- Step 3 【链表拼接】. 维护前序已合并的链表的尾指针tail，后序待处理链表的头指针next，将其和上述sub_head、sub_tail拼接起来。并更新tail，next指针。
- 注意用哨兵节点简化：头结点不确定时的操作


### 23.合并K个升序链表

**朴素找头结点最小值**
- 顺序遍历K路链表集合
- 找到K路链表中，最小元素的那一路子链表，空链表跳过
- 摘取元素追加到总链表中，更新子链表的头指针
- （破坏了原lists集合，且顺序遍历找最小值太慢了）

**最小堆/优先队列的运用**
- 难点：自定义一个节点的最小优先队列加速找最小值（第一次用最小堆）
- 每次从最小堆pop出最小节点，然后把该路的下一个节点push进去维护
```cpp
// 用lambda表达式声明比较函数
auto cmp = [](const Listnode* a, const Listnode* b){
	// 比较器返回true，代表左的优先级低于右的
	return (a->val > b->val); // 值越大，优先级越低，最小堆
	// return !(a->val > b->val); // 反之是最大堆
};

// 比较函数要用decltype获取类型，底层存储采用vector
priority_queque<Listnode*, vector<Listnode*>, decltype(cmp)> pq; 
```


**迭代版归并排序**
-  148.排序链表 的某个中间状态
- 但K路有序序列通过vector承接（而 148.排序链表 是直接在一个链表上原地操作）
- 【数组索引归并】直接利用数组索引，很方便，每次将归并的结果，整合至第一个位置
- 可以不断增大step，进行两两归并，最后总的结果一定会在`lists[0]`
- 【数组索引归并】模版参考 排序专题：归并排序

**递归版归并排序**
- 


### 146.LRU缓存
- 常数时间插/查：哈希表能实现 **常数时间** 检索/插入
- LRU：用双向链表，最近使用就将**该节点**就取到头部
- 难点1：get/put时，如何在 **常数时间** 在双向链表中定位到 **该节点** ？
- 难点2：双向链表末尾发生缓存驱逐时，如何定位到哈希表同步做erase？
- 应对难点1：【哈希表到链表】哈希表存<key, addr> addr指向链表节点，value放到链表中
- 应对难点2：【链表到哈希表】链表节点存<key, value> 一定要有key！！！用于定位到哈希表
- 其他难点：（1）**双向链表维护**操作，如何实现：1.节点定义和初始化；2.节点的摘除；3.节点的头插；（2）注意保持哈希表和双向链表的**视图一致**
- 摘除和头插：显式获取prev、victim、next三个 **节点指针**，再进行节点 **链表指针** 的修改

## 专题：二叉树

### 0.前/中/后/层次遍历的非递归实现

**前序遍历：**
- 用stack实现；
- 访问并弹出栈顶元素（root），然后先右后左的次序把孩子入栈
```cpp
void pre_visit(Node* root) {
	stack<Node*> st;
	
	st.push(root);
	while (!st.empty()) {
		Node* top = st.top(); st.pop();
		visit top;
		if (top->right != nullptr) st.push(top->right); // 注意先右后左顺序，注意判断空指针
		if (top->left != nullptr) st.push(top->left);
	}
}
```


**中序遍历：**
- 难点：左节点被访问完前，根节点无法被访问
- 用stack实现；
- 访问并弹出栈顶元素（root）**前**，要将左孩子要全部入栈，然后再**转向**右节点。（注意，转向后继续沿用该套路）
```cpp
void in_visit(Node* root) {
	stack<Node*> st;
	Node* cur;
	
	cur = root;
	while (cur != nullptr || !st.empty()) {
		while (cur != nullptr) { // 左孩子全部入栈
			st.push(cur);
			cur = cur->left;
		}
		
		Node* top = st.top(); st.pop(); // 访问当前节点
		visit top;
		
		cur = top->right; // 转向右子树
	}
}
```

**后序遍历**
- 难点：左节点和右节点都被访问前，根节点无法被访问
- 用stack实现
- 双栈法：用 “结果栈” 将 “左-右-根”的 后序遍历 转化为 “根-右-左” 的类前序遍历
- 单栈标记法：大致类似于中序遍历；但此处额外要控制根节点 “经过但不访问”（等待右孩子）
```cpp
// 双栈法
void post_visit(Node* root) {
	vector<Node*> st1;
	vector<Node*> st2;
	
	// 根-右-左 类前序遍历
	st1.push(root);
	while(!st1.empty()) {
		Node* top = st1.top(); st1.pop();
		st2.push(top);
		
		if(top->right != nullptr) st1.push(top->right);
		if(top->left != nullptr) st1.push(top->left);
	}
	
	// 访问结果栈
	while(!st2.empty()) {
		Node* top = st2.top(); st2.pop();
		visit top;
	}
}

// 单栈标记法
void post_visit(Node* root) {
	stack<Node*> st;
	Node* cur = root;
	Node* last_visit = nullptr;
	
	while(cur != nullptr || !st.empty()) {
		while(cur != nullptr) {  // 左孩子全部入栈
			st.push(cur);
			cur = cur->left;	
		}
		
		Node* top = st.top(); // 查看，但不访问
		
		// 有右子树，且右子树未被访问（不是从右子树回来的）
		if (top->right != nullptr && top->right != last_visit) { // 处理右子树 入栈处理
			cur = top->right;
		}
		else { // 访问根节点
			top = st.top(); st.pop();
			visit top;
			last_visit = top;
		}
	
	}
}
```


**层次遍历**：
- 用queue实现；
- 访问并弹出队头元素，然后将左右孩子入队
```cpp
// 普通版
void level_visit(Node* root) {
	queque<Node*> q;
	
	q.push(root);
	while (!q.empty()) {
		Node* head = q.front(); q.pop(); // 访问并弹出队头元素
		visit head;
		if(head->left != nullptr) q.push(head->left); // 左右孩子入队
		if(head->right != nullptr) q.push(head->right); 
	}
} 

// 进阶版：按层为batch
void level_visit_plus(Node* root) {
	queue<Node*> q;
	
	q.push(root);
	while (!q.empty()) {
		int sz = q.size(); // 获取当前层size
		while (sz > 0) { // 按层做batch
			// 同普通版
		}
		xxx; // 层处理逻辑, 如计算深度
	}
}
```


### 94.二叉树的中序遍历

**递归方法**
- 对谁递归：对左右子树分别递归遍历
- 递归处理：重点在将左、右、自身的结果进行拼接
- 停止条件：空节点，返回空数组

**迭代方法**
- 见0.前/...的非递归实现


### 104.二叉树的最大深度

**递归方法**
- 左/右深度的最大值+1

**迭代方法**
 - batch版的层次遍历

### 226.翻转二叉树

**递归方法**
- 递归遍历所有节点
- 将左/右孩子交换

### 101.对称二叉树

**递归：子树匹配法**
- 将树的对称问题，转换为两个子树的对比匹配
- 难点：但传统的一维递归，没法处理这种匹配问题
- 引入双维/双变量的递归处理匹配问题
- （1）left和right的值是否匹配
- （2）递归匹配left->left和right->right
- （3）递归匹配left->right和right->left
- 停止条件：处理空节点的匹配

**迭代：层次遍历**
- 同样基于子树匹配问题
- 子树left从左往右做层次遍历，用queue q1
- 子树right从右往左做层次遍历，用queue q2
- 每次访问节点的时候，都比较一下是否相等
- 此题最好把空节点也push进去队列中，处理起来简洁一点
- 注意q1和q2遇到空指针的处理

### 543.二叉树的直径

**递归方法**
- 二叉树的直径一定来自于：某个节点（未必是根节点）左/右子树深度的和
- 直接遍历所有节点，计算每个节点的深度（见104.二叉树最大深度）
- 在递归处理过程中，维护一个max_val，记录左/右子树深度的和

### 102.二叉树的层序遍历

**迭代方法**
- 参考0.前/.../的非递归实现；batch版的层序遍历


### 108. 将有序数组转换为二叉搜索树

**递归方法**
- 二分构建 <-> 平衡二叉树
- 本身递增 <-> 自然而然 形成搜索树
- 采用递归的二分法：对<left, right>构建
- 对谁递归：有序数组的左右子区间
- 递归构建：递归得到的左/右子节点，和当前根节点建树
- 停止条件：同二分搜索：left > right

### 98.验证二叉搜索树

**递归：子树区间法**
- 以根节点为中心视角考虑会很难受，无法判别子树的子树和根节点大小关系
-  要对左/右子树递归，那就转换一下问题视角
- 转换视角：验证左/右子树是否满足由根节点划分形成的区间
- 递归构建：root节点满足区间不？递归对左右子树判断满足区间不？都满足则pass
- 停止条件：空节点始终true

**迭代：中序遍历法**
- 对二叉搜索树做中序遍历，得到的结果一定是递增序列

### 230.二叉搜索树中第K小的元素

**迭代：中序遍历**
- 中序遍历，visit到第k个就break
- 缺点：如果频繁查找，每次都要从头遍历和访存/匹配，很低效

**递归：子节点数**
- 封装为一个类为每个节点维护一个子节点数
- 通过子节点数，做二分查找
- 若 left 的子节点数 > k-1，则进入left；若等于k-1，则返回node；若 < k-1，则进入right



==**AVL树：TODO**==
### 199.二叉树的右视图

**迭代：层次遍历**
- 见 0.前/../的非递归实现 中 batch层次遍历
- 记录每一层的最后一个元素

**递归：右子树优先**
- 维护：深度！自顶向下的距离！而不是高度，不是自底向上！（相同深度取最右）
- 用带hint/深度记录的递归，每递归一层就深度+1
- 先递归右孩子，再递归左孩子；保证同层一定是最右的先访问到
- 由于hint/深度记录是自顶向下传的，不用等待递归返回结果
- 往结果数组push元素的时候，先push（满足深度等于数组大小）再递归

### 114.二叉树展开为链表

**递归：先序遍历**
- 用递归版先序遍历，直接得到先序遍历结果数组
- 基于该结果数组，接构建一个链表

**迭代：先序遍历**
- 借助栈先序遍历，把节点树型关系维护在栈中
- 遍历/访问到某节点，就直接拼接成单链表（修改上个节点的左右指针）
- 只要将左右孩子push进栈，后续该节点左右指针就不会再用到了，放心的修改就行了
- 需要记录上一个节点

**双指针：前驱节点**
- 先序遍历重要性质：左子树最右/最后一个访问的节点（前驱节点），紧挨着右子树的根节点
- 因此，右子树“剪”下来后，要挂到上述前驱节点prev的右指针处
- 然后，原来的左子树变为右子树
- 重复进行，直到遍历完所有节点（cur == nullptr）


### 105.由前序与中序遍历序列构建二叉树

**递归构造法**
- 建树很适合用递归(
- 此外，要充分利用好先序/中序遍历的递归特点
- 先序：根 【左先序】 【右先序】；中序：【左中序】根 【右中序】
- 注意【左先序】与【左中序】长度相等，右边同理
- 每次递归时，先序第一个元素就是根，然后去查中序就知道下一轮递归的左/右的中/先序范围
- 查找中序时，可以预构建一个hash_map加速查找
- 但这样后，递归就要基于原数组，用pre_l、pre_r、in_l、in_r圈出每轮的pre和in数组范围
- 处理新的左/右的中/先序范围是最麻烦的，建议简单画个图示（{pre_l ... pre_r}、{in_l ... idx  ... in_r}），和显式标记长度len便于处理

**==迭代构造法 （TODO）（只是初步理解）==**
- **先序性质：** 顺序遍历先序序列（根->左->右），相邻两个元素u v。只有两种情况：（1）v是u的左孩子（很直接）；（2）v是某祖先节点的右孩子（即某祖先节点左子树访问完了，回溯去访问**右**子树了，因为根已经访问过了）
- 如何判断是（1）还是（2）？借助 **中序序列**
- **中序性质：** 中序的第一个元素m代表当前 **最左节点**
- 利用两序列都优先访问左子树，再访问右子树特点做协同设计。
- **设计原理**：
	- Step1 顺序遍历先序序列，只要没遇到m，说明v一定是u的左孩子。 因为如果是情况（2），说明左子树已经遍历完了，要回溯去找右子树了。可m代表当前最左节点啊，说明左子树没遍历完！
	- Step2 两者匹配，则需要一直回溯，模拟中序访问根节点，这意味着刚刚一路左子树；当中序不匹配了，说明进入右子树了，即情况（2）。
	- Step3 然后将右子树节点入栈，继续处理右子树
- 难点1：如何模拟回溯？使用栈结构，和先序先访问根的特性。
- 难点2：如何模拟建树？用一个指针遍历中序序列，利用先序特性判断是否该进入右子树了，利用回溯寻找右子树的父节点
- 总结：
	- **栈顶 ≠ 中序当前** ->添加为左子节点，继续向左
	- **栈顶 = 中序当前**  -> 弹出栈顶，中序指针后移
	- **栈顶 ≠ 中序当前**（在弹出后） -> 添加为右子节点


### 437.路径总和Ⅲ

**递归遍历**
- 采用带hint/总和标记的递归 search(node, sum) 计算每个节点满足条件路径数
- 递归子节点 search(node, sum - root->val)
- 满足sum的路径未必过根节点，需要遍历所有节点 dfs(node)
- 注意：dfs函数可以直接构造返回值为总路径数
- 注意：注意考虑节点为0的情况，不要一相等就提前返回导致漏解

**前缀和优化**
- 观察1：二叉树，根节点到任意节点的路径只有一条
- 观察2：两节点<u,v>（路径的长度）=<root,v>（当前前缀和）-<root,u>（历史前缀和）
- 即，目标历史前缀和 = 当前前缀和 - 目标路径长度
- 关键：将目标长度的路径查找 转化为 目标历史前缀和 的查找问题
- 目标历史前缀和次数 <-> 目标长度（且以v结尾）的路径数
- dfs 遍历每个节点时，计算前缀和并记录和增加路径数
- 注意：前缀和重点是 **前缀**，这意味着 dfs 的前缀和视图只能对子节点生效，不能对其他分支生效；故进入进入子分支前，节点前缀和引用+1，离开子分支后节点前缀和引用-1
- 注意：需要添加一个前缀和为0的虚拟根节点，来处理路径从根节点出发的情况
- 注意：dfs 的返回值可以直接设计为总路径数

### 236.二叉树的最近公共祖先

**递归：深度优先搜索**
- 天然具备找“最近”/“最深”的特点
- 遍历每个节点，判断 自身、左节点、右节点 三者是否满足，包含 p **和** q
- 注意：dfs 返回值应构造 自身、左节点、右节点 三者是否满足为是否“包含” p **或** q，便于递归逻辑处理。
- 最先遇到（最近/最深）的作为res结果记录

**存储父节点**
- 第一遍用 dfs 遍历整个数，记录每个节点的父节点在hash_map里
- 第二遍从p出发访问其所有父节点，塞入hash_set里
- 第三遍从q出发访问其所有父节点，如果遇到hash_set里的就立刻返回
- 这个效率没有上面高

### 124. 二叉树中的最大路径和

**递归：前缀和**
- 【问题改造】<u, t, v> 构成的路径长度，可以改造为前缀和形式：(<root, u> - <root, t>) + (<root, v> - <root, t>)
- 【前缀和】<root, t>固定，构建带hint/前缀和信息的递归可以实时获取
- 故，需要让<root, u>和<root, v>最大即可
- 【递归构建】dfs 的返回值 构造为子节点及其往下到root的前缀和最大值；故res在dfs(node->left) / dfs(node->right) / 和该节点的前缀和 中取max
- 【结果记录】遍历过程中维护max_path，考虑几种情况取路径的max：<u,t,v>（三者不重合）/ <t,v> （t和u重合） / < t >（t和u和v重合）

## 专题：图论

### 0.普通无向图的dfs/bfs遍历

**邻接矩阵与图遍历**
- 邻接矩阵`vector<vector<int>> graph`存储了每个图节点 `node` 的邻居节点数组
- 无向图遍历均需要`visited`数组，用来避免重复访问节点
- 有向图无需`visited`数组，因为有遍历方向（类似于二叉树），但会用`visited`数组用来避免环。见 207.课程表

**DFS**
- 对**所有邻居**递归，**跳过被访问**过的邻居
```cpp
vector<int> visited;
void dfs(vector<vector<int>>& graph, int u){
	visited[u] = 1;
	for (auto node : graph[u]) {
		if (!visited[node]) dfs(graph, node);
	}
}

...
int n = graph.size();
visited.resize(n);
```

**BFS**
- 把所有邻居入队，跳过被访问过的邻居
```cpp
void bfs(vector<vector<int>>& graph, int u) {
	int n = graph.
	vector<int> visited(n);
	queue<int> q;
	q.push(u); visited[u] = 1;
	while (!q.empty()) {
		int head = q.front(); q.pop();
		for (auto node : graph[head]) {
			if (!visited[node]) { q.push(node); visited[node] = 1; }
		}
	}
}
```

其他变体，基于此修改，最核心是`visited`数组。
### 200.岛屿数量

**DFS搜索**
- 将矩阵看作网格图，其实就是数多少个连通子图
- 对网格图进行dfs搜索：访问完该节点，将节点插旗，继续访问上下左右邻居节点
- 直到碰到水，或者是之前出界，或者是其他插旗节点
- 插旗是为了图的dfs时，保持有向性，防止来回跳跃
- 技巧：使用**方向数组**来让代码更加优雅
- 二叉树和网格图的对比

| 对比项 | 二叉树 | 网格图 |
|:--|:--|:--|
| **递归入口** | 根节点 | 岛屿第一行最左边的陆地 |
| **递归方向** | 左儿子和右儿子 | 左右上下的相邻陆地 |
| **递归边界** | 空节点（或者叶节点） | 出界、遇到水或者已访问的标记 |

**BFS搜索**
- 核心思路和DFS搜索一样
- 不同之处在于替换搜索算法，用队列代替递归做搜索
- 将节点入队，然后要紧接着将节点插旗，然后访问节点时，把上下左右邻居节点全部入队
- 一定要push的时候就标记访问，不然一个节点会被重复push

**并查集**
- 并查集，类似于分组，将相关的元素划分到相同集合，元素合并会带着其所在的**集合一同合并**
- 为了实现集合合并，要为每个集合维护一个“组长”`parent`，集合合并时即完成**组长的指向**
- 查询`find`组长时递归查询，组长的指针一定指向自己。查到了更新组长信息（路径压缩）
- 元素的组长相同，则其处于相同的集合
- 最后并查集能维护有多少个分组，看有多少个组长；可以通过维护一个count变量，实现O(1)查询。
- 为了避免树太高，导致合并的时候，尽可能让小树挂在大树下（这样高度就不变）。为组长维护树的高度近似`rank`来决定谁挂谁。只在两棵树高度相等情况下增加被挂树的高度`rank`。`find`的时候不去改`rank`，不然成本太高。
- **并查集模板**
```cpp
class UnionFind {
	vector<int> leader; // 记录组长关系
	vector<int> rank; // 记录高度，实现平衡
	int cnt; // 记录连通分量，快速返回
	
	// 初始化并查集
	UnionFind(int n) {
		leader.resize(n);
		rank.resize(n);
		cnt = n;
		for (int i = 0; i < n; i++)
			leader[i] = i; // 每个节点初始化为组长
	}
	
	// 寻找组长
	int find(int x) {
		if (leader[x] == x) return leader[x]; // 组长元素
		leader[x] = find(leader[x]); // 非组长元素递归找组长，找到后更新指向组长
		return leader[x]; 
	}
	
	// 合并操作
	void unite(int x, int y) {
		int leaderX = find(x);
		int leaderY = find(Y);
		if (leaderX == leaderY) return;
		
		// 更新leaderX和leaderY的parent指向
		if (rank[leaderX] < rank[leaderY]) 
			leader[leaderX] = leaderY;
		else if (rank[leaderX] > rank[leaderY])
			leader[leaderY] = leaderX;
		else {
			leader[leaderY] = leaderX;
			rank[leaderX] ++; // rank只在此处更新
		}
		
		cnt--;
	}
	
	bool connected(int x, int y) {
		return find(x) == find(y);
	}
	
	int count() {
		return cnt;
	}
}
```


### 994.腐烂的橘子

**多源BFS**
- 有多个源头一起同时进行BFS。这和 batch版的层次遍历很像。
- 初始化时，将所有源头入队。
- 然后每次batch出队里所有源头，只去感染新鲜橘子，成功感染了才时间`time`++。
- 注意初始化时需要维护一个新鲜橘子总数`fresh`，以判断多源BFS结束后，新鲜橘子被感染完没。
- 新鲜橘子入队的时候，就要将其标记，以免重复入队（同200.岛屿数量的BFS）。
- 同样可以用方向矩阵D优化代码。

### 207.课程表

**三色DFS**
- 此题可以看成一个有向图（拓扑图）是否成环，有向边拓扑关系表示为 `i->j`  表示 `i` 先 `j` 后
- 使用 `vector<vector<int>>` 构建邻接表，核心基于 0.普通图的dfs遍历
- dfs用栈进行有向图的遍历时，如果节点还在栈里，而再次被遍历到时，则出现了环
- 升级visit数组，细分被访问状态，分为**还在递归栈中**，和已完成访问（三个状态/**三色**）
- 对每个节点都做一次dfs，判断是否出现环

**BFS拓扑排序**
- 按照拓扑排序摘取节点：每次摘取入度为0的节点，并删除其所在边（邻居的入度减一）
- 找入度为0的点：高效的办法是维护一个入度为0的节点队列（避免每次都查找入度数组`in`）
- 从按入度为0节点开始BFS遍历，pop/摘取节点时，更新邻居的入度；如果为0，就push进队列做BFS
- 注意1：这里BFS无需维护`visited`数组判环，有向图的遍历是有方向的
- 注意2：成环的节点一定不会入队列，其入度一定不可能减为0
- 注意3：初始时一定要把所有入度为0的节点都push进队列，避免图不连通的遗漏

### 208.实现Trie (前缀树)

**两个哈希集合**
- 一个前缀哈希集合，一个单词哈希集合

**前缀26叉树**
- 用树来表示前缀、以及不同词的公共前缀。最小化存储空间，重复构建等。
- 构建树节点：（1）一个节点表示一个字母，要想连接子节点，需要26个分叉（静态数组比vector更高效）；（2）此外为了记录单词的结束信息，要给节点维护是否结束字段。
- 初始化和销毁：初始化创建一个头节点，销毁采用递归销毁整棵树。
- 插入单词：从头节点一路往下，安放word；没有子节点就创建子节点；最后一个节点标记为结束
- 查询单词/前缀：和插入单词一样，从头往下遍历；返回没找到？以及找到是否为结束节点？

## 专题：回溯

![[Pasted image 20251113111434.png | 500]]

**回溯基本概念**
- 概念：“回溯” = “尝试 + **撤销**”的**DFS搜索**过程（DFS 只负责“走”，回溯负责控制“走”的方向，撤销是为了复用路径数组，不用重新开新数组）
- 核心：利用递归的进入和返回机制，控制递归新进入的状态/视图不同，生成结果的逻辑也不同。一个位置，做多次不同输入状态的dfs（不同可能，多叉树的遍历）。
- 做法：每次dfs进入前设置不同的状态，进行结果获取。当dfs退出后恢复原来状态，供下一次dfs设置不同状态。
- 注意：回溯，天然适用于深度优先搜索（利用栈的良好的回退机制，利用回退做撤销）。回溯不建立在 BFS 之上（BFS不会回头）。
```cpp
vector<vector<int>> res; // 所有分支的结果
vector<int> path; // 每条分支的产生的最终结果

void back(args) {
	if (xxx) { // DFS终点
		res.push_back(path); // 收集结果
		return;
	}
	for (auto c : choice) { // 遍历当前层所有选择
		path.push_back(xxx); // 在该选择下，修改路径，进入递归
		back(new_args); // DFS新参数
		path.pop_back(); // 回退，为做新选择做准备
	}
}
```



### 46.全排列
- 普通DFS没有撤销的能力，只适合做已知形状的遍历和搜索
- 回溯则能控制这个形状所有可能，做全排列
- 全排列要求已经被选择的元素不能再被选择，因此用`on_path`数组看某个元素是否在`path`上被选择
- DFS采用自顶向下的hint/层数参数，填充`path`数组指定位置
- 进入DFS时，标记这层做的选择`on_path`，退出后清空标记
- 每一层遍历所有可能的参数`path[depth]`，做多次DFS


### 78.子集

**位运算**
- 幂集的性质 -> 一定有2^n个set，对应到2^n个数set_num
- 如果`set_num`某个`j`位为1，代表`nums[j]`元素要选
- 通过位运算`set_num >> j & 1`来判断某一位是不是1

**回溯**
- 递归到depth层 -> nums 第depth层 元素 选还是不选
- 即使本层只有两个分支，还是得恢复现场，否则回溯到上一层时，会影响兄弟分支

### 17.电话号码的组合
- depth层 -> 对应的数字的字母集合中，选择哪一个字母

### 39.组合总和
- 此题是是完全背包的搜索版；DP （有几种方式）不适合输出所有组合，而回溯（所有“组合”全部列出来）天然擅长列举路径
- 如何进行DFS：此题的搜索深度（depth）不是固定的，由 target 的剩余值决定是否继续搜索
- 如何保证不能选前序元素？否则会出现`[2,2,3]`和`[2,3,2]`的重复。需要限制可遍历元素，以保持元素选择的顺序性，只能访问从哪里开始的元素（start）
- 剪枝优化（提前return），将candidates排序，如果可选元素大于target了，直接返回

### 22.括号生成
- n对括号，则递归深度有`2*n`层
- 每层可以选择产生"("还是产生")"
- 但是要按照括号匹配逻辑，限制'('和')'的产生：（1）个数限制，如果'('/')'产生个数小于n，才能产生；（2）匹配限制，'('数目大于')'数目，才能产生')'，不然一定违法

### 79.单词搜索
- 此题是单词匹配，即搜索 + 匹配。
- 不能像之前的题目，一直搜索到depth == sz，才去比较单词，搜索空间太大，而且要维护path字符串
- **基本** 这类题目一定要：一边搜索，一边匹配，不匹配的不用继续搜索，实现剪枝，也无需维护path。能匹配到和抵达`depth==sz-1`，匹配成功，停止（成功条件）。
- DFS的搜索思路，同 200.岛屿数量，均为网格图
- **优化1** 在搜索时，但凡一个分支匹配成功，其他dfs就不用继续了，通过全局`res`判断
- **优化2** 原地插旗，直接将原board访问过的元素设置为`#`，不用visited数组（同200.岛屿数量）
- **优化2** 频数分析，如果word的字母频数大于board的字母频数，一定不成功；匹配可以逆向匹配，word首/尾字母谁频数更低，带来的搜索空间就越小

## 专题：栈
### 20.有效的括号
- push一个起始节点
- 遇到右括号，则pop进行匹配。否则，push。
- 全部成功匹配，stack应该只剩起始节点

### 155.最小栈
- 由于栈每次pop/push元素，其min元素都会发生改变（状态特性）
- 用一个正常栈 st 同步实现满足各种栈
- 用一个最小栈 min_st **同步**每个栈操作/每个状态的min元素

### 394.字符串解码

**一栈到底**
- 用一个栈`stack`完成解析
- 如果遇到`]`，就依次把子串`substr`，和前缀数`numstr` pop出来，把处理中间结果再push回去
- 操作完整个string后，栈中就是最终解析结果，弹出并返回
- 用`isalpha`判断字母，用`isdigit`判断数字

**递归**
- 递归天然维护栈结构，可自然用于表达式解析；将`k[xxx]`定义为展开式。
- 递归逻辑：如果遇到`k[xxx]`，则`xxx`需要递归展开。
- 递归处理：每层递归负责解析从当前位置开始的 字母、数字、子展开式，直到遇到本层的 `]` 为止。
- 递归返回：自己处理的展开式的展开结果
- 注意：如果没遇到子展开式，是全字母，直接`break`返回结果，这层递归是不可能遇到`]`的。
- 难点：注意所有层递归要共享一个遍历指针 i，子递归会把遍历指针更新到自己层对应`]`处，外层需要执行 `i++` 跳过这一层的 `]`（如果是纯字母，则是最后一个位置）。外层继续 while，继续扫描后面的内容（如下一个展开式），直到遇到自己层的 `]` 就break。

### 739. 每日温度

**单调栈**
- 每天都对应有自己的适合的那个元素，让其保持（在栈中），直到找到适合的那个元素
- 单调栈通过维护一个递减序列，一旦违反减性（递增），则会弹栈，天然的判断“递增”特性
- 栈顶是最新且最小元素，是最先要被处理的
- 用一个栈，遇到比栈顶元素大一直pop，然后压入新温度保持单调性
- 为了计算位置，采用的是栈中压入的是索引

## 专题：堆
### 215.数组中的第K个最大元素

**快速选择：朴素划分**
- 几种划分的核心思想参考：排序专题 快速排序
- 第 k 大的元素，索引为 n - k
- 朴素划分返回实打实的pivot索引pos，且最终位置已经确定
- 因此pivot一定为索引为pos的元素
- 那如何找特定索引为 idx 的元素呢？
- 每次比较 返回的pos 和 目标索引idx 的大小，进行单侧递归
- 如果返回的pos和k相等，那么该pivot就是预期元素（位置判定）
- 优势：早停机制（不必等到 left == right），缺点是重复元素划分不均衡会退化（超时）

**快速选择：霍尔分区**
- 霍尔划分返回分区边界 `j`
- 注意：`idx` == j，说明不了任何东西，因为 j 不是pivot位置
- 但如果 `idx` <= j，能说明索引为`idx`元素一定在 (left, j) 区间；否则，一定在 (j+1， right) 右边（区间判定）
- 要递归到区间收敛，即 left == right 才能确定，索引为 `left == right == idx`  
- 优势：均衡机制（可以避免划分不均衡的退化）

**快速选择：三路分区**
- 三路划分返回分界边界 lt, gt （lt, gt标记了与pivot相等的区间）
- 区间`[lt, gt]`和朴素划分的`pos`一样，pivot的最终位置已经确定，只是一个是数，一个是区间
- 如果 索引 `idx` 落在区间`[lt, gt]`，则表示该索引已经成功找到
- 否则则递归单侧区间
- 优势：重复跳过

**堆查找**
- 核心思想参考：排序专题 堆排序
- 建堆，然后取k次，就返回

**计数查找**
- 核心思想参考：排序专题 计数排序
- 这里做一点简单修改：（1）得到count数组后，无需计算前缀和；（2）从后往前遍历count数组，用k去减，让k减为0的那个元素第K大；（3）再次注意恢复出元素要加min_val。
- 时间复杂度是 O(N+K), 非标准的O(N)

### 347. 前K个高频元素

**快速选择**
- 首先要对原数组进行预处理，用哈希表`<num, hotness>`统计每个元素出现频率，然后用一个数组vector存储`<num, hotness>`用于对`hotness`排序。
- 然后用快速选择算法，参考 215.数组中的第K个大元素，找到第K大元素，然后其右边的所有元素就是top-K元素。
- 注意，需要简单修改，对`vector<pair<int,int>>`排序，排序依据是第一个元素`.second`。

**桶排序**
- 普通数组排序 -> 按照数据大小分桶
- 前K高频 -> 按照一个频率一个桶，将数据全部分桶
- 哈希表频数统计 -> 按频数分桶 -> 倒着遍历桶，取top-k频率

**堆排序：调API版 / 手搓**
- 同样需要用哈希表做频数统计
- 维护大小为 k 的小顶堆/优先队列，排序依据是`<num, hotness>`中的hotness（pair的second）。新元素要比堆顶元素（top-k的bar）大，才能加入堆。
- 最后遍历优先队列，取pair的first就是答案

## 专题：贪心
### 121.买卖股票最佳时机
- 顺序遍历的同时
- 维护当前遇到最小元素
- 用当前元素减去该最小元素
- 记录上述整个过程中差值的最大值

### 55.跳跃游戏

**朴素遍历法**
- 维护一个结果数组res；
- 顺序遍历原数组，从下标 i 出发 步进 `nums[i]` 步数，标记res数组


**贪心1：最远抵达**
- 利用：只要能跳到最远的n，那么n之前的所有位置一定可达
- 遍历数组nums，维护每个元素的“最远抵达距离” max_val，即i + `nums[i]`
- 当max_val大于数组长度，即可达

**贪心2：大胆步进，遇0回退**
- 利用：`nums[i]` 都是正数，只要没遇到0都会前进
- 因此，大胆步进 next = i + `nums[i]`就行了，别遇到0就可以
- 要是真遇到0了，就回退探测，如果回退到头了还不行就表示真的不行

### 45.跳跃游戏Ⅱ

**贪心：最大步进**
- 跳跃问题的升级版: 假设一定可达, 求最短跳跃数
- 【关键】在当前位置 dst 的 可行解Q 里，寻找能跳的最远的作为下一跳 next_dst
- 因为 最远下一跳 dst = next_dst 的下一步 可行解Q 最大
- 反证：倘若该跳  dst 不可达，则其他跳一定不可达（其他跳的可行解包含在Q里），而题目说一定可达
- 【难点：边界处理】
- 【1 最后一个元素不跳了】dst 抵达最后一个元素 不用 jump 了，及时判断并break
- 【2 跳完优先级高于跳远的】否则一定会jump，并在（1）可行解里选 i + `nums[i]` 最大的作为next_dst；（2）如果 i + `nums[i]` 已经超出数组范围了，将next_dst停留在 i 然后可以停止了。其中（2）的优先级高于（1），能跳完，就不用选跳更远的！

## 专题：动态规划

**动态规划的共性**：往回推上一步，有n种可能的动作空间（n是有限的，可以是2，也可以是100），因此对应着递推式的n个子问题。

### 70. 爬楼梯
**递归方程** 
- 爬到 n 台阶往回推一步，有两种可能（子问题）： 爬到 n-1 台阶和爬到 n-2 台阶
- 即，f(n) = f(n-1) + f(n-2)
**基本条件** 
- 第1个台阶只有1种可能，第2个台阶有2种可能
**过程存储** 
- 直接递归会timeout；
- 要会用dp表存储中间过程的值，避免子问题重叠计算，空间换时间
- 此题只用前两个状态，用完以后再也不用了，可以只存储最近两个状态

### 118. 杨辉三角
（这道题准确来说不叫动态规划）
**过程存储**
- 按部就班的存储状态，并利用上一行计算下一行

### 198.打家劫舍
**递归方程**
- 抓住两步不能相邻这个条件。打劫到n的最高金额往回推一步，有两种可能：打劫到 n-1 的最高金额（由于相邻，到此截止）；打劫到 n-2 的最高金额  +  n位置处的金额。两者取最大值。
- 即，f(n) = max(f(n-1), f(n-2) + `rob[n]`)
**基本条件**
- 打劫到1的金额；打劫到2的金额
**过程存储**
- 类似于70.爬楼梯


### 279.完全平方数
**递归方程**
- 组成数n最小，往回推一步，即其（减掉一个平方数x + 1）的所有可能中的最小。
- 即，f(n) = min{f(n-`sq[i]`) + 1}, 遍历`sq[i]`
**基本条件**
- f(1) = 1，后续都可以推出来
- 甚至 f(1) = 1 也直接用平方数判别
**过程存储**
**注意事项**
- 注意遇到平方数的边界处理：设置f(0)=0
- 比大小，多用min和max函数
- 最大值替换为 INT_MAX 和 INT_MIN `(#include <climits>)`

### 322.零钱兑换
**递归方程**
- 兑换零钱n最少，往回推一步，即其（减掉一个零钱 + 1）的所有可能中最小。（同完全平方数）
- 即，f(n) = min{f(n - `coins[i]`) + 1}, 遍历`coins[i]`
**过程存储、基本条件、注意事项**
- 同完全平方数。
**遍历方式**
- 从下往上，f(1) -> f(n)
- 从上往下， f(n) -> f(1)，搜索 + 过程存储，即记忆化搜索


### 139.单词拆分
**递归方程**
- 串s是否能被拼成，则取决于其去掉前缀的串s'能否被拼成
- 即，f(str) = if any true { f( str - `word[i]` ) } 遍历 `word[i]`
**递归方程2**
- 长度为n的串s是否能被拼成，取决于其长度为 n-ti 的字串能否拼成，其中 ti 是`word[i]`的长度
- 即，f(n) = if any true { f(n-ti) }，每次都要基于f(0)...f(n-1)历史结果，从头算起
**过程存储**
- 哈希表
**遍历方式**
- 从上往下，即递归记忆化搜索，最简单直接
- 从下往上，貌似没有可演进的规律，那么就构造可演进的递归。比较复杂。每轮都基于历史结果，硬生生从头算起。


### 300.最长递增子序列
**难点解析**
- 难点1：子序列是可以不连续的
- 难点2：随着不断迭代，最长递增子序列是可能改变的
- 解析：
	- 基于上述两个"变"，原问题不是直接的最优子结构问题。
	- 对递归方程（递归优化问题的构建，和递归关系）无法遵循以往的确定性思路
	- 需要对原问题稍稍做改变以构成最优子结构问题
- 突破口：
	- 递增子序列一定产生于和之前最大元素的对比
	- 将原问题改造为：以`nums[i]`元素【结尾】的最长递增子序列（确定性）
	- 迭代过程中，能够直接比较前序所有元素，来决定子序列是否递增
**递归方程**
- `nums[n]`结尾的最长递增子序列，往回推一步，取决于max（前面`nums[i]`结尾的最长递增子序列+1），其中 `nums[n]` > `nums[i]`
- 即，f(n) = f(i) + 1 遍历 if `nums[n]` > `nums[i]`, i < n
**过程存储**
**第二种解答**
- 将时间复杂度降到O(nlong(n))
- **贪心 + 二分查找**
- **step 1** 维护tail数组，`tail[k]` 代表长度 k+1 子序列的 **最小尾部元素** （最小 -> **贪心**思想，贪心才能）
- **step 2** 遇到大于 `tail[k]` 的数，直接 append ，长度加一
- **step 3** 遇到小于 `tail[k]` 的数，采用 **二分查找** 更新 tail 数组，朝着让尾部元素最小的方向走
- 注意，上述 tail 并非维护最终的递增子序列，只维护了其长度，发生 step 3 的覆盖也没事，不影响长度判别
- 同时上述 tail 一定是递增的
- **民间例子**：比如序列是78912345，前三个遍历完以后tail是789，这时候遍历到1，就得把1放到合适的位置，于是在tail二分查找1的位置，变成了189（如果序列在此时结束，因为res不变，所以依旧输出3），再遍历到2成为129，然后是123直到12345。
- **民间解释**：遍历nums拿出来的比我当前tail尾部更小的数，我遇见了就把它换进来，要是后续不能让这些稍小（相较于tail数组的尾部）的变成更长的子序列，那就超不过原先的，我也没有任何损失，但如果长度能超过之前的这些，我前面已经替换完了，随时准备着和你后面的组成更长的，只需要你来加到尾部就ok了。

### 152.乘积最大子数组
**前序题目：** **53.最大子数组和**
**难点解析**
- 负数特性：由于 负数 的震荡性（负负得正，正负得负），可能让结果 最小 -> 最大 -> 最小
- 面临问题：最优解可能在中途被 “丢弃”，不具备最优子结构
**解决办法**
- 同时将记录以当前元素结尾的 正max_arr数组 和 负min_arr数组；并依据 `nums[i]` 正负性维护以上两个数组

### 416. 分割等和子集
**难点分析**
- 将等和子集转化为0-1背包问题的变体（等和版本）
- 可以借助等和子集的一些特性做一些边界优化加速
**递归方程**
- f(n, cap) = f(n-1, cap) | | f(n-1, cap-`nums[n]`)
**启动条件**
- 完全相等才能true (0-1背包变体)
- （0-1背包是小于等于就能true）
**实现方法**
- 递归 + 记忆化搜索
- 自底向上非递归
**关于 （1）递归+记忆化搜索 和 （2）自底向上非递归 的对比**
![[Pasted image 20251029155431.png]]

### 32.最长有效括号 

**栈匹配**
- 要算长度，所以用索引栈
- 用索引访问数组即可访问对应符号
- 索引栈初始化为-1，边界处理，便于计算长度
- 遇到 ')' 就尝试匹配 '('，匹配了就pop()并计算一次长度max_val
- 其他情况都直接push索引

## 专题：多维动态规划
### 62.不同路径
- 动作空间，只有两个
- 上一步只有两种可能
- f(i,j)= f(i-1,j) + f(i,j-1)
### 64.最小路径和
- 在上述基础上，
-  f(i,j) = min{ f(i-1,j), f(i,j-1) } + `nums[i][j]

### 5.最长回文子串
- 回文特点：从某个中心（开始条件）向两边拓展（迭代设计）
- 开始条件：f(i,i) = 1; f(i,j) = 2 if `s[i] `== `s[j]`
- 两边拓展：f(i,j) = f(i+1,j-1) + 2 if f(i+1,j-1) > 0 && `s[i]` == `s[j]`
- 遍历顺序（关键）：从”串的长度“入手, len = 3 -> n; i = 1 -> n 且 j = len + i - 1;

**优化：**
- 遍历每一个元素（i->0,...,n）
- 从开始条件向两边一直拓展，直到没法拓展为止
- 记录整个过程的最大长度，及其起始位置

### 1143.最长公共子序列
- 大致思路同：72.编辑距离
- 讨论两者的末尾符号e
- 1) e1 = e2, f(S1, S2) = f(S1-e1, S2-e2) + 1;
- 2) e1 ≠ e2, f(S1, S2) = max{ f(S1-e1,S2), f(S1, S2-e2) }

### 72.编辑距离
- **问题定义**: S1 - ops(操作) - S2
- 转化为 S1 和 S2 的比较，对其子串进行迭代构造
- 讨论两者的末尾符号e
- 1) e1 = e2, f(S1,S2) = f(S1-e1, S2-e2) use add
- 2) e1 ≠ e2, f(S1,S2) = min{ f(S1-e1,S2) use add,  f(S1, S2-e2) use add, f(S1-e1, S2-e2) use replace }
- 遍历顺序（关键）： 考虑上述几种子情况在二维dp表的方位：左；下；左下
- 故按右遍历，往上常规遍历即可
- 开始条件：f(0,0) = 0, f(0, x) = xxx, f(x, 0) = xxx


## 专题：二分查找

### 35.搜索插入位置

- **二分查找的模板**

```cpp

int left = xx, right = xx;

while (left <= right) { // 考虑边界 当left == right时，出现等于时

	int mid = left + (right - left) / 2; // 防止整数溢出

	// 1) 在arr中找到第一个大于target的位置	
	if (target >= arr[mid])  // 大于/小于关系: target为了找相等元素要往哪里走
							// 等于关系处理，看想找第一个大于还是找最后一个小于
		left = mid + 1;
	else 
		right = mid - 1;

	return left;
	
	// 2) 在arr中找到最一个小于target的位置
	if (target <= arr[mid])
		right = mid - 1;
	else
		left = mid + 1;
	return right;
}


```





## 专题：技巧

### 136.只出现一次的数字
- 利用异或性质：（1）两个相同的数异或会变为0；（2）0和一个数异或还是那个数
- 逐个遍历数组，取异或

### 169.多数元素

**哈希表**
- 天然适合统计次数，当遇到次数大于 n / 2 就返回

**快速选择**
- 排序后索引为 (n-1) / 2 的元素是众数（奇数数组的中间元素，偶数数组的前半段末尾元素）
- 因此用快速选择算法即可

**随机化**
- 随便选择一个数，1/2的概率是众数
- 选择然后验证即可，不断重复直到找到，按照概率论选到的概率越来越大

**分治 | 垃圾方法**
- 将大数组均分为两子数组；大数组的众数，一定也是某个子数组的众数
- 直接在两个子数组的众数中得出，两者谁是众数
- 两者相等则直接是众数，两者不相等则统计两者在 left 至 right 出现的次数，看谁更多谁是

**投票算法**
- 车轮战，擂台同阵营打榜。与擂主元素相同则加入；不同则削减；为0则更换擂主。
- 最后能留下的阵营，一定是众数，凭借人多的优势
- 为什么：众数元素阵营经得起一半的消耗。即使其他非众数元素都是一个阵营，最多也只能消耗不到一半；更别考虑他们不是一个阵营还会互相消耗。


## 专题：排序算法


- ==TODO== 参考题目 912.排序数组

### 归并排序

**递归写法**
- 【核心思想】将一个大数组排序拆分为两个小数组的排序（分治），然后对排好序的左右两个子数组做归并（合），即可得到一个有序的大数组。
- 实际实现上，可以分为两种：（1）递归时返回新vector；（2）递归时修改原vector

**递归之（1）返回新vector**
- 【递归处理】寻找中点`mid`分为两个子数组，递归处理子数组。将子数组**拷贝传入**，创建**新的vector**来承接得到的合并结果并返回，空间复杂度为 O(NlogN)（注意c++没有切片的概念，子数组只能复制）
- 【递归返回】排序后的 **新的结果vector**
- 【递归结束条件】一个元素的数组或者空，直接返回（即nums.size() <= 1）。
- 【注意1】相当于用递归栈，存储了很多 通过递归拆分 带来的 **中间结果vector**，然后递归返回时，再逐渐将这些新结果拼接。
- 【注意2】归并时优雅且统一写法是，子数组`vec1[i++]`, `vec2[j++]`和总数组 `nums[k++]` 来表示
```cpp
vector<int> merge(const vector<int>& vec1, const vector<int>& vec2){
	int n1 = vec1.size(), n2 = vec2.size();
	vector<int> res(n1 + n2);
	
	int i=0, j=0, k=0; // k从0开始，是新数组
	while (i < n1 && j < n2) {
		if (vec1[i] <= vec2[j]) res[k++] = vec1[i++];
		else res[k++] = vec2[j++];
	}
	while (i < n1) res[k++] = vec1[i++];
	while (j < n2) res[k++] = vec2[j++];
	
	return res;
}

vector<int> sort(const vector<int>& nums) {
	int n = nums.size();
	if (n <= 1) return nums;
	int mid = n / 2;
	vector<int> left(nums.begin(), nums.begin() + mid);
	vector<int> right(nums.begin() + mid, nums.end()); 
	
	auto vec1 = sort(left);
	auto vec2 = sort(right);
	
	auto res = merge(vec1, vec2);
	
	return res;
}
```

**递归之（2）修改原vecor**
- 【递归处理】同样划分和递归。**但** 传入 **索引定位**，要将两个有序子数组进行**原地归并**到原vector上。每次合并时需要对左右两个子数组做一份 **拷贝**，空间复杂度为 O(N)
- 【递归返回】为`void`，直接对原数组操作
- 【递归结束条件】一个元素的数组或者空，直接返回（即left >= right）。
- 【注意1】直接在原数组上完成上述逻辑，相当于递归栈永远只有一个原数组，但存储了原数组的不同状态。注意采用原数组上的 **索引** 作为递归和合并处理的参数
```cpp
// 难点/麻烦在于归并, 优雅且统一写法是，用子数组vec1/2[i/j++]和总数组nums[k++]
// left...mid; mid + 1...right
void merge(vector<int>& nums, int left, int mid, int right) {
	int n1 = mid - left + 1;
	int n2 = right - (mid + 1) + 1;
	int i, j, k;
	
    // 从总数组拷贝到子数组
	vector<int> vec1(n1), vec2(n2); 
    i = 0, j = 0, k = left; // 注意k中left开始，是原数组
	while (i < n1) vec1[i++] = nums[k++]; 
	while (j < n2) vec2[j++] = nums[k++];
	
	// 将子数组归并到总数组
	i = 0, j = 0, k = left;
	while (i < n1 && j < n2) { // 都不空选小的
		if (vec1[i] <= vec2[j]) nums[k++] = vec1[i++];
		else nums[k++] = vec2[j++];
	}
	while (i < n1) nums[k++] = vec1[i++]; // 空了直接归并另一个
	while (j < n2) nums[k++] = vec2[j++];
}

void sort(vector<int>& nums, int left, int right) {
	if (left >= right) return ;

	int mid = left + (right - left) / 2;
	sort(nums, left, mid);
	sort(nums, mid+1, right);
	merge(nums, left, mid, right); // 递归后merge
}
```


**迭代写法**
- 【核心思想】将一个大数组从最小的有序数组（只有一个元素一定是有序的）开始逐渐归并和壮大。每次都将相邻的两个有序数组两两归并，扩大有序数组的大小。
- 【步长】采用渐进的步长step（从1开始，小于n，每次*=2），控制归并的有序数组的大小
- 【起始】归并起始位置 i （从0开始，i + sz < n，每次+= 2 * sz）, * 2 是 因为两两一组归并
- 【注意1】要两两归并，注意处理：（1）无法凑成两两的情况（即第二个区间的首元素 i+sz 仍要小于 n），生成“尾巴”；（2）能勉强凑成配队，但第二个不够sz，归并区间会以数组最后一个元素n-1结尾。
- 【注意2】没有匹配到的“尾巴”，会随着sz的增大，会自动落入一个更大的归并区间中。落单元素可以理解为与空合并。最后随着step增大，前面一定会合成align的大链表，落单元素只是链表更小一点，最后两者一定会合并为最终大链表。
```cpp
// n = 7 尾部元素
// R0: [A0], [A1], [A2], [A3], [A4], [A5], [A6]
// R1: [A0, A1], [A2, A3], [A4, A5], [A6]
// R2: [A0, A1, A2, A3], [A4, A5, A6] -> 之前的尾部元素 [A6] 参与合并
// R3: [A0, A1, A2, A3, A4, A5, A6]

// n = 9 尾部元素
// R0: [A0], [A1], [A2], [A3], [A4], [A5], [A6], [A7], [A8]
// R1: [A0, A1], [A2, A3], [A4, A5], [A6, A7], [A8]
// R2: [A0, A1, A2, A3], [A4, A5, A6, A7], [A8]
// R3: [A0, A1, A2, A3, A4, A5, A6, A7], [A8]
// R4: [A0, A1, A2, A3, A4, A5, A6, A7, A8] -> 之前的尾部元素 [A8] 参与合并
```
- 迭代归并模版：
```cpp
void sort(vector<int>& nums) {
	int n = nums.size();
	
	for (int sz = 1; sz < n; sz *= 2) {
		for (int i = 0; i + sz < n; i += sz * 2) {
			int left = i, mid = i + sz - 1, right = min(i + 2 * sz - 1, n  - 1);
			merge(nums, left, mid, right);
		}
	}
}
```

### 插入排序
- 【核心思想】将数组分为有序、无序两个部分。每次从无序部分中取出元素，插入到有序部分对应的位置中（类似于 **扑克牌理牌**）
- 难点是：（1）找对应的位置，需要向后挪动元素，因此采用**从后往前**遍历；（2）此外，需要保存无序部分取出的元素cur，向后挪动的时候会发生覆盖（比较的时候也**要用cur**，不能再用`nums[i]`）！（3）注意停下来的**位置要加1**，才是要插入的位置（上次被搬走剩下来的位置）
```cpp
void sort(vector<int>& nums) {
	int n = nums.size();
	// 第0个元素默认有序
	for (int i = 1; i < n; i++) {
		int cur = nums[i]; // 无序取出的元素
		int j;
		for (j = i - 1; j >= 0 && nums[j] > cur; j--) // 从有序的最后一个元素往前比
			nums[j+1] = nums[j];
		nums[j+1] = cur; // 最后停下的位置就是要插入的位置
	}
}
```

### 希尔排序
- 【出发点】改进插入排序，解决逐个挪动元素的低效问题。
- 【核心思想】先大阔步挪动元素，再小步伐局部微调元素
- 【实现方式】（1）分gap组插入排序，每gap步的元素在一个分组；（2）大gap实现大阔步，小gap实现小步伐；（3）gap从n/2开始减半，逐渐缩小到1

```cpp
void sort(vector<int>& nums) {
	int n = nums.size();
	for (int gap = n / 2; gap > 0; gap /= 2){ // 逐步缩小gap，调整步伐
		// 从gap开始，遍历所有元素
		for (int i = gap; i < n; i++) {
			int cur = nums[i]; // 做一下备份
			// 但只在对应的组内做“插入排序” （相隔gap）
			int j;
			for (j = i - gap; j >=0 && nums[j] > cur; j -= gap) {
				nums[j+gap] = nums[j]; // 往后挪
			}
			nums[j+gap] = cur;
		}
	}
}
```


### 快速排序
- 【核心思想】随机选择一个元素pivot作为中枢，将原数组中小于或大于该元素的**划分**成两个区间，然后递归处理两个区间。（与归并是递归后merge不同，快排是递归前partition）
- 重点在于划分函数：如何将数组的元素划分为两个区间，并返回中枢pivot所在位置，供下一次划分。
- 【方法1】朴素划分，返回pivot位置。pivot所在位置的左边一定都是小于pivot的元素。（1）指针`i`从(left) -1位置开始，**定位和接收** 所有小于pivot的元素。（2）然后另一个指针`j`则从(left) 0位置开始遍历(到right-1)，**寻找** 所有小于pivot的元素。（3）如果找到了则将指针`j`的元素**swap**到指针`i`一侧。（4）一直到`j`遍历完数组，i 停下的位置都是满足小于pivot的元素，**下一个位置** 则是pivot该放的位置；（5）注意找到该位置后，一定要将原来的pivot放swap到这个位置，后续这个位置就不再处理了。pivot中途会被移动，不再是pos位置，就会找不到pivot，没法swap到正确位置。因此通常将选取的pivot交换到 **最后一个位置**，然后 j 遍历到倒数第二个位置，来显式的标记和规避对pivot移动。（6）**返回pivot位置**供下一次划分。
```cpp
#include <cstdlib>
int partition (vector<int>& nums, int left, int right) {
	int pos = left + rand() % (right - left + 1);
	int pivot = nums[pos];
	swap(nums[pos], nums[right]);
	
	int  i = left - 1;
	for (int j = left; j < right; j++) 
		if (nums[j] <= pivot) 
			swap(nums[++i], nums[j]);
			
	swap(nums[++i], nums[right]);
	return i;
}

void sort(vector<int>& nums, int left, int right) {
	if (left >= right) return;
	
	int pos = partition(nums, left, right);
	sort(nums, left, pos - 1);
	sort(nums, pos + 1, right);
}
```
- 【方法2】霍尔分区，返回均衡分区边界。如果遇到重复元素，上述朴素划分会退化为O($N^2$)，单边递归，划分不均衡。（1）指针 i 和 指针 j 分别从两边往中间走，i 起始为 left - 1, j 起始为 right  + 1。（2）++i去找并停在 ≥ 第一个pivot元素，-- j去找并停在 ≤ 第一个pivot元素，然后交换两个元素。i 走完，j 走，保证对称和均衡。（3）直到两者相遇或交错（i >= j）就break，划分停止。i-1定位≤pivot区间，j+1定位≥pivot区间）。（4）故最后下次划分区间为(left, i-1)，(i, right) 或者 (left, j), (j+1, right)，具体看返回i or j。（5）注意是返回分区位置（而非中枢位置），因此递归也是递归子分区（包含返回分区位置）。（6）不会将 pivot 移到中间，pivot在哪并不知道，仅仅承诺分区i or j的结果正确。
```cpp
int partition(vector<int>& nums, int left, int right) {
	int i = left - 1, j = right + 1;
	int pos = left + rand() % (right - left + 1);
	int pivot = nums[pos];
	while (i < j) {
		while (nums[++i] < pivot);
		while (nums[--j] > pivot);
		if (i < j) swap(nums[i], nums[j]);
	}
	return j;
}

void sort(vector<int>& nums, int left, int right) {
	if (left >= right) return;
	int pos = partition(nums, left, right);
	sort(nums, left, pos);
	sort(nums, pos + 1, right);
}
```
- 【方法3】三路分区，严格返回<，=，>的分界位置。（1）用两个指针 `lt` 和 `gt` 区分出等于pivot的范围（`lt` - 1就是 < 开始的位置， `gt` + 1就是>开始的位置）。（2）注意三路分区的`lt`指针和`gt`指针要从left和right开始，因为他们不是为了像前两个方法一样`lt` 和 `gt` 的职责不是“收纳满足条件的元素”，而是“框定区间边界”，使中间的“== pivot 区域”逐步形成并扩张。（3）从gt交换过来的元素不要i++，因为`i`右边过来的元素是没有经过处理和判断的元素。
```cpp
pair<int, int> partition(vector<int>& nums,  int left, int right) {
	int pos = left + rand() % (right - left + 1);
	int pivot = nums[pos];
	int lt = left, gt = right, i = left;
	
	while (i <= gt) {
		if (nums[i] < pivot) swap(nums[i++], nums[lt++]);
		else if (nums[i] > pivot)  swap(nums[i], nums[gt--]);
		else i++;
	}
	
	return {lt, gt};
}

void sort(vector<int>& nums, int left, int right) {
	if (left >= right) return ;
	auto [lt, gt] = partition(nums, left, right);
	sort(nums, left, lt-1);
	sort(nums, gt+1, right);
}

```

### 堆排序
- **堆** 是完全二叉树（紧密排布，基于数组）。对于完全二叉树，i 的左子节点一定是 `2i+1`，i 的 右子节点一定是 `2i+2`，父节点 一定是 `(i-1)/2`。
- **最大堆** 任意节点的值 ≥ 所有子节点的值
- **插入** 将新元素放到堆末尾。如果其大于父节点，则 **不断上移与交换** （注意父节点被换下来，也一定会满足最大堆性质）
- **取出** 堆顶元素被取出后，位置空缺。用**堆底**元素暂时填补，然后将其 **不断下移** 和把左/右节点换上去（堆性质，更大的上）
- **建堆** 从最后一个非叶子节点 `n / 2 - 1` 开始调整（因为叶子节点天然是最大堆）。要自底向上调整/**不断下沉**节点到合适位置（只要底部是最大堆，下沉调整得到的一定是最大堆）。
- **堆排序** 把整个数组建堆，每次取出最大的放数组末尾（注意堆排序没有用到上移操作）
- **注意**：其实堆插入/堆取出/建堆几个操作，核心就是两个函数 某个节点`i`的上移`heap_up` 和某个节点`i`的下沉 `heap_down` 
```cpp
void heap_up(vector<int>& nums, int i) { // i 为 新插入元素的位置
	while (i > 0) { // 不断上移
		int parent = (i - 1) / 2;
		if (nums[i] > nums[parent]) swap(nums[i], nums[parent]);
		else break;
		i = parent;
	}
}

void heap_down(vector<int>& nums, int n // 传入n是考虑堆排序nums size会发生改变
	, int i) { // i 为 要调整/下沉元素的位置
	while (i < n) {
		int parent = i;
		int left = 2 * i + 1, right = 2 * i + 2;
		// 存在儿子，且儿子更大，则让儿子当爸
		if (left < n && nums[left] > nums[parent]) parent = left;
		if (right < n && nums[right] > nums[parent]) parent = right;
		if (parent == i) break; // 没下沉，结束
		swap(nums[parent], nums[i]); // 交换
		i = parent; // 下沉
	}
}

void sort(vector<int>& nums) {
	int n = nums.size(); // 注意，出现的所有n都不是索引，而是大小
	
	// 建堆
	int last = n / 2 - 1; // 最后一个非叶节点 
	for (int i = last; i >= 0; i--) {
		heap_down(nums, n, i);
	}
	
	// 取最大元素
	for (int i = n - 1; i > 0; i--) {
		swap(nums[0], nums[i]);
		heap_down(nums, i, 0);
	}
	
}
```


### 计数排序
- 核心思想：不做数与数的比较也能排序（不内卷），将统计每个数出现的次数（相同的数）及其相对位置（不同的数），来推断其应该所处的位置（专注自己）。
- 如何记录将数的大小变为数的相对位置呢？将数的大小直接变为数组索引（`idx` = `num` - min_val），出现就加1（记录自己），然后累加前缀和（记录前面个数，从而得知自己位置）。
- 最后从后往前遍历（保证算法稳定性）一遍数组，就知道每个数所处的位置。排序一个数，就将对应的count减一。
- 注意1：count数组代表索引`idx`映射的数`num`出现多少次、count前缀数组内容索引`idx`映射的数`num`是结果数组的**第几个**/**第几小** （如果要写入最终结果数组要**减1**）。
- 注意2：时间复杂度为O(N+K)， 但是空间复杂度为O(N+K), 要看数的范围K，和数字长度N谁大
```cpp
vector<int> sort(vector<int>& nums) {
	// count 位置数组
	int max_val = INT_MIN, min_val = INT_MAX;
	for (auto num : nums) {
		max_val = max(max_val, num);
		min_val = min(min_val, num);
	}
	int m = max_val - min_val + 1;
	int n = nums.size();
	vector<int> count(m);
	for (int i = 0; i < n; i++) 
		count[nums[i] - min_val] ++;
	for (int i = 1; i < m; i++)
		count[i] += count[i-1];
	
	// 填充结果数组
	vector<int> res(n);
	for (int i = n-1; i >= 0; i--) {
		int pos = count[nums[i] - min_val] - 1;
		count[nums[i] - min_val] --;
		res[pos] = nums[i];
	}
	
	return res;
}
```

### 桶排序
- 桶排序与其说是一种算法，其更像一个框架
- **思想** 桶排序按照特定方式，将原始数据分为n个桶，每个桶内调用特定排序算法排序。然后按照桶的顺序，直接将不同桶的结果自然拼接，即可得到最终结果。
- **复杂度** 如果每个桶的元素很少，则桶内趋近于O（1）复杂度。由于自然拼接，桶间的复杂度是O（n）。总的时间复杂度是O（n）。
- **分桶** 最简单的方式是给每个桶设置大小值范围`<min, max>`，遍历一遍原数组，满足范围的数落在桶中。分的桶越多，数据越均匀，复杂度越趋近O（n）。
```cpp
void sort(vector<int>& nums)  {
	vector<vector<int>> buckets(n);
	for (auto num : nums) 
		select bucket and push_back;
	for (auto& b : buckers) sort(b.begin(), b.end());
}
```